///<reference path="./defLoader.d.ts" />
/**
 * Config
 *
 * @module :: Config
 * @description	:: Classe Typescript permettant la configuration de l'exemple.
 */
var Engine;
(function (Engine) {
    var Config = (function () {
        function Config() {
        }
        /**
         * Permet de mettre à jours dynamiquement le décalage en pixel des Tiles.
         * @method calculateOffset
         * @static
         */
        Config.calculateOffset = function () {
            this.offsetX = (Engine.Config.gameScreenX / 2) - (Engine.Config.tileWidth / 2);
            this.offsetY = Engine.Config.tileHeight;
        };
        /**
         * Largeur de la zone de jeu de base en pixel.
         * @property gameScreenX
         * @type {number}
         * @static
         */
        Config.gameScreenX = 1024;
        /**
         * Hauteur de la zone de jeu de base en pixel.
         * @property gameScreenY
         * @type {number}
         * @static
         */
        Config.gameScreenY = 768;
        /**
         * Largeur d'une Tile en pixel sur la carte du jeu.
         * @property tileWidth
         * @type {number}
         * @static
         */
        Config.tileWidth = 100;
        /**
         * Hauteur d'une Tile en pixel sur la carte du jeu.
         * @property tileHeight
         * @type {number}
         * @static
         */
        Config.tileHeight = 50;
        /**
         * Largeur de la texture d'une Tile en pixel l'image du Tileset
         * @property tileTextureWidth
         * @type {number}
         * @static
         */
        Config.tileTextureWidth = 100;
        /**
         * Hauteur de la texture d'une Tile en pixel l'image du Tileset
         * @property tileTextureHeight
         * @type {number}
         * @static
         */
        Config.tileTextureHeight = 100;
        return Config;
    })();
    Engine.Config = Config;
})(Engine || (Engine = {}));
//# sourceMappingURL=Config.js.map
///<reference path="./defLoader.d.ts" />
var __extends = this.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    __.prototype = b.prototype;
    d.prototype = new __();
};
/**
 * GameMap
 *
 * @module :: GameMap
 * @description	:: Classe permettant de regrouper les différentes cartes de notre exemple.
 */
var Engine;
(function (Engine) {
    /**
     * Attention, vous remarquerez qu'ici, nous n'exportons pas la classe. Celle-ci est créer et exporter en bas de page afin
     * qu'elle soit bien prise en compte comme conteneur statique.
     */
    var GameMapStatic = (function (_super) {
        __extends(GameMapStatic, _super);
        function GameMapStatic() {
            _super.apply(this, arguments);
        }
        /**
         * Permet de charger une carte.
         * @method loadMap
         * @static
         *
         * @param mapConfig {any}       Paramètres de la carte qui doit être chargé.
         */
        GameMapStatic.prototype.loadMap = function (mapConfig) {
            this.addChild(new Engine.Map(mapConfig));
        };
        return GameMapStatic;
    })(PIXI.DisplayObjectContainer);
    /**
     * On créer et exporte la classe afin qu'elle soit statique
     */
    Engine.GameMap = new GameMapStatic();
})(Engine || (Engine = {}));
//# sourceMappingURL=GameMap.js.map
///<reference path="./defLoader.d.ts" />
var __extends = this.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    __.prototype = b.prototype;
    d.prototype = new __();
};
/**
 * Map
 *
 * @module :: Map
 * @description	:: Classe permettant de crée une carte du jeu.
 */
var Engine;
(function (Engine) {
    var Map = (function (_super) {
        __extends(Map, _super);
        /**
         * Constructeur
         *
         * @param mapConfig {any}       Objet au format JSON contenant les paramètres de la carte à réaliser.
         */
        function Map(mapConfig) {
            _super.call(this);
            /**
             * Contient la liste des numeros des Tiles utilisé pour dessiné la carte.
             *
             * @property _ground
             * @type {number[]}
             * @private
             */
            this._ground = [];
            // On applique les données de la carte aux variables
            this._ground = mapConfig.data;
            this._tileWidth = mapConfig.width;
            this._tileHeight = mapConfig.height;
            this._tilesetUrl = mapConfig.url;
            // On demande le chargement du Tileset
            Engine.Tileset.load([this._tilesetUrl]);
            // Scope
            var self = this;
            // Une fois le Tileset correctement chargé, on demande l'affichage de la carte
            Engine.Tileset.onReady(this._tilesetUrl, function (tileset) {
                self._draw();
            });
        }
        /**
         * Permet de dessiné la carte
         * @method _draw
         * @private
         */
        Map.prototype._draw = function () {
            // On va chercher le Tileset afin d'obtenir le tableau contenant la liste des textures des différentes Tiles
            var tileset = Engine.Tileset.getTileset(this._tilesetUrl), tileCounter = 0;
            for (var y = 0; y < this._tileHeight; y++) {
                for (var x = 0; x < this._tileWidth; x++) {
                    // Création de la Tile en lui envoyant sa texture et sa position
                    this.addChild(new Engine.Tile(tileset.getTile(this._ground[tileCounter]), x, y));
                    // On incremente le compteur de Tile
                    tileCounter++;
                }
            }
        };
        return Map;
    })(PIXI.DisplayObjectContainer);
    Engine.Map = Map;
})(Engine || (Engine = {}));
//# sourceMappingURL=Map.js.map
///<reference path="./defLoader.d.ts" />
var __extends = this.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    __.prototype = b.prototype;
    d.prototype = new __();
};
/**
 * Scene
 *
 * @module :: Scene
 * @description	:: Classe permettant la cr�ation de sc�ne.
 */
var Engine;
(function (Engine) {
    var Scene = (function (_super) {
        __extends(Scene, _super);
        /**
         * Constructeur
         *
         * @param color {number} optional       Permet de d�finir une couleur d'arri�re plan de la sc�ne.
         *                                      Cette couleur doit �tre au format h�xadecimal.
         */
        function Scene(color) {
            _super.call(this, color || 0xffffff);
            /**
             * Check if Scene is already started 1 time
             * @type {boolean}
             * @private
             */
            this._started = false;
            /**
             * Permet de d�finir le status de pause de la sc�ne
             * @type {boolean}
             * @private
             */
            this._paused = false;
        }
        /**
         * Cette fonction est appel� juste avant chaque d�marrage de la sc�ne.
         *
         * @method beforeResume
         */
        Scene.prototype.beforeResume = function () {
            if (!this._started) {
                this.onStart();
                this._started = true;
            }
        };
        /**
         * Cette fonction est appel� lors du premier d�marrage de la sc�ne. Son appel est donc unique.
         * Elle est principalement utilis� par les classes enfants.
         *
         * @method onStart
         */
        Scene.prototype.onStart = function () {
        };
        /**
         * Mise � jour de la sc�ne quand celle-ci est active.
         *
         * @method update
         */
        Scene.prototype.update = function () {
        };
        /**
         * Permet la mise en pause de la sc�ne.
         *
         * @method pause
         */
        Scene.prototype.pause = function () {
            this._paused = true;
        };
        /**
         * Permet la mise en marche de la sc�ne
         *
         * @method pause
         */
        Scene.prototype.resume = function () {
            this._paused = false;
            this.beforeResume();
        };
        /**
         * Permet de conna�tre si la sc�ne est en pause ou non.
         *
         * @method pause
         * @return {boolean}        Retourne le status "pause" de la sc�ne
         */
        Scene.prototype.isPaused = function () {
            return this._paused;
        };
        return Scene;
    })(PIXI.Stage);
    Engine.Scene = Scene;
})(Engine || (Engine = {}));
//# sourceMappingURL=Scene.js.map
///<reference path="./../defLoader.d.ts" />
var __extends = this.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    __.prototype = b.prototype;
    d.prototype = new __();
};
/**
 * GameScene
 *
 * @module :: GameScene
 * @description	:: Classe permettant de cr�e la sc�ne de "jeu" de l'exemple.
 */
var Engine;
(function (Engine) {
    var GameScene = (function (_super) {
        __extends(GameScene, _super);
        /**
         * Constructeur
         */
        function GameScene() {
            _super.call(this);
            /**
             * Contient le conteneur des cartes
             *
             * @property _gameMapContainer
             * @type {PIXI.DisplayObjectContainer}
             * @private
             */
            this._gameMapContainer = Engine.GameMap;
            // On ajoute le conteneur de la carte � la Sc�ne de jeu
            this.addChild(this._gameMapContainer);
        }
        /**
         * Cette m�thode permet l'�xecution de param�tres lors du premier d�marrage de la sc�ne uniquement.
         * @method onStart
         */
        GameScene.prototype.onStart = function () {
            _super.prototype.onStart.call(this);
            // On calcule le d�calage de la carte afin qu'elle soit centr� correctement
            Engine.Config.calculateOffset();
            // Taille de la carte en Tile
            var mapWidth = 10, mapHeight = 10;
            // G�n�ration de la carte
            var generatedMap = {
                data: Engine.Utils.generateMap(mapWidth, mapHeight, 0, 10),
                url: 'assets/images/ayolan-tilesetIsometrique.png',
                width: mapWidth,
                height: mapHeight
            };
            // Puis on lance son chargement
            Engine.GameMap.loadMap(generatedMap);
            // On cache le conteneur de la carte par d�faut
            this._gameMapContainer.alpha = 0;
        };
        /**
         * Permet la mise � jour de la sc�ne.
         * @method update
         */
        GameScene.prototype.update = function () {
            // Apparition en fondu de la carte
            if (this._gameMapContainer.alpha < 1) {
                this._gameMapContainer.alpha += 0.01;
            }
            _super.prototype.update.call(this);
        };
        return GameScene;
    })(Engine.Scene);
    Engine.GameScene = GameScene;
})(Engine || (Engine = {}));
//# sourceMappingURL=GameScene.js.map
///<reference path="./../defLoader.d.ts" />
var __extends = this.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    __.prototype = b.prototype;
    d.prototype = new __();
};
/**
 * IntroScene
 *
 * @module :: IntroScene
 * @description	:: Classe permettant de cr�e la sc�ne d'introduction de l'exemple.
 */
var Engine;
(function (Engine) {
    var IntroScene = (function (_super) {
        __extends(IntroScene, _super);
        /**
         * Constructeur
         */
        function IntroScene() {
            _super.call(this);
            /**
             * Cette variable permet de conna�tre si l'animation est en phase d'apparition ou disparition.
             *
             * @property _tilesetList
             * @type {object}
             * @private
             */
            this._out = false;
            // On charge le logo de Pixi.js puis on l'ajoute � la Sc�ne
            this._logo = PIXI.Sprite.fromImage("assets/images/logo.png");
            this.addChild(this._logo);
            // On fait un aggrandissement sur le logo de Pixi afin qu'il ai la taille de la sc�ne
            this._logo.scale.x = this._logo.scale.y = Engine.SceneManager.defaultWidth / (Engine.SceneManager.defaultWidth / 2);
            // On prend comme point d'accroche le centre de l'image
            this._logo.anchor.x = this._logo.anchor.y = 0.5;
            // On rend le logo transparent afin d'avoir un effet de fondu lors de l'ouverture de la page
            this._logo.alpha = 0;
            // On d�place le logo au centre de l'�cran
            this._logo.position.x = Engine.SceneManager.defaultWidth / 2;
            this._logo.position.y = Engine.SceneManager.defaultHeight / 2;
        }
        /**
         * Permet la mise � jour de la sc�ne.
         * @method update
         */
        IntroScene.prototype.update = function () {
            _super.prototype.update.call(this);
            if (!this._out) {
                if (this._logo.alpha < 1) {
                    this._logo.alpha += 0.01;
                }
                else {
                    this._out = true;
                }
            }
            else {
                if (this._logo.alpha > 0) {
                    this._logo.alpha -= 0.01;
                }
                else {
                    Engine.SceneManager.goToScene('game');
                }
            }
        };
        return IntroScene;
    })(Engine.Scene);
    Engine.IntroScene = IntroScene;
})(Engine || (Engine = {}));
//# sourceMappingURL=IntroScene.js.map
///<reference path="./defLoader.d.ts" />
/**
 * SceneManager
 *
 * @module :: SceneManager
 * @description	:: Classe statique permettant de manager toute les différentes scènes de notre exemple/jeu.
 */
var Engine;
(function (Engine) {
    var SceneManager = (function () {
        function SceneManager() {
        }
        /**
         * Permet la création du système de rendu
         * @method create
         * @static
         *
         * @param width {string}                                Largeur en pixel par défaut du rendu
         * @param height {string}                               Hauteur en pixel par défaut du rendu
         * @param rendererOptions {PIXI.PixiRendererOptions}    Options de rendu de PIXI
         * @param divId {string}                                Id de la div ou doit être ajouter le rendu
         * @return {SceneManager}                               On retourne la classe
         */
        SceneManager.create = function (width, height, rendererOptions, divId) {
            // On vérifie si le rendu est déjà actif
            if (SceneManager.renderer) {
                return SceneManager;
            }
            // On applique les valeur de taille par défaut
            SceneManager.defaultWidth = SceneManager.width = width;
            SceneManager.defaultHeight = SceneManager.height = height;
            // On crée et assigne le rendu
            SceneManager.renderer = PIXI.autoDetectRenderer(SceneManager.width, SceneManager.height, rendererOptions);
            // Si l'utilisateur à soumis une div dans laquelle doit etre ajouter le rendu, on l'utilise, sinon, on ajoute le rendu au document.
            if (divId) {
                document.getElementById(divId).appendChild(SceneManager.renderer.view);
            }
            else {
                document.body.appendChild(SceneManager.renderer.view);
            }
            // On lance le système de rendu
            requestAnimFrame(SceneManager.loop);
            return this;
        };
        /**
         * Cette "boucle sans fin" permet la mise à jour automatique de la scène active.
         * @method loop
         * @static
         */
        SceneManager.loop = function () {
            requestAnimFrame(function () {
                SceneManager.loop();
            });
            // On la scène est en pauve ou qu'aucune scène n'est disposible, on stop
            if (!this.currentScene || this.currentScene.isPaused())
                return;
            // Sinon, mise à jour de la scène active
            this.currentScene.update();
            // Mise à jour du rendu de la scène active
            this.renderer.render(this.currentScene);
        };
        /**
         * Permet la création de scène
         * @method createScene
         * @static
         *
         * @param id {string}       Id de la scène à créer
         * @param CScene {Scene}    Contient la classe de la scène qui va être créer
         * @return {Scene}          Retourne la scène qui vient d'être créer
         */
        SceneManager.createScene = function (id, CScene) {
            // On vérifie si la scène n'existe pas
            if (SceneManager._scenes[id]) {
                return void 0;
            }
            // Si c'est le cas, on l'a crée et l'associe à son id
            SceneManager._scenes[id] = new CScene();
            // Puis on l'a retourne
            return SceneManager._scenes[id];
        };
        /**
         * Permet de changer de scène d'après son id
         * @method goToScene
         * @static
         *
         * @param id {string}       Id de la scène qui doit devenir active
         * @return {boolean}        True si tout s'est bien passé, false si aucun changement n'a eu lieu
         */
        SceneManager.goToScene = function (id) {
            if (SceneManager._scenes[id]) {
                // Si une scène est active, on la met en pause
                if (SceneManager.currentScene) {
                    SceneManager.currentScene.pause();
                }
                // On change de scène puis on l'active
                SceneManager.currentScene = SceneManager._scenes[id];
                SceneManager.currentScene.resume();
                return true;
            }
            return false;
        };
        /**
         * Contient l'ensemble des scènes crée
         *
         * @property _scenes
         * @type {object}
         * @private
         * @static
         */
        SceneManager._scenes = {};
        return SceneManager;
    })();
    Engine.SceneManager = SceneManager;
})(Engine || (Engine = {}));
//# sourceMappingURL=SceneManager.js.map
///<reference path="./defLoader.d.ts" />
var __extends = this.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    __.prototype = b.prototype;
    d.prototype = new __();
};
/**
 * Tile
 *
 * @module :: Tile
 * @description	:: Classe permettant la création d'une Tile.
 */
var Engine;
(function (Engine) {
    var Tile = (function (_super) {
        __extends(Tile, _super);
        /**
         * Constructeur de la classe Tile.
         *
         * @param texture {Boolean}         Permet de définir si la Tile doit être intéractive ou non.
         * @param isoX {Number}             Position isométrique X et la Tile
         * @param isoY {Number}             Position isométrique Y de la Tile
         */
        function Tile(texture, isoX, isoY) {
            // Applique la texture de la Tile au Sprite
            _super.call(this, texture);
            // Mise en place de la Tile à la bonne position
            this.position.x += (isoX - isoY) * (Engine.Config.tileWidth / 2) + Engine.Config.offsetX;
            this.position.y += (isoX + isoY) * (Engine.Config.tileHeight / 2) + Engine.Config.offsetY;
            // Puis on y ajoute l'intéractivité
            this._setInteractivity(true);
        }
        /**
         * Permet d'ajouter ou supprimer l'intéractivité d'une Tile.
         * @method _setInteractivity
         * @private
         *
         * @param interactive {Boolean}     Permet de définir si la Tile doit être intéractive ou non.
         */
        Tile.prototype._setInteractivity = function (interactive) {
            if (interactive) {
                // Rend la Tile interactive
                this.interactive = true;
                // Création de la zone de collision avec la souris
                this.hitArea = new PIXI.Polygon([
                    new PIXI.Point(50, 25),
                    new PIXI.Point(100, 50),
                    new PIXI.Point(50, 50 + 25),
                    new PIXI.Point(0, 50)
                ]);
                // Application d'une teinte quand la souris survol la tile
                this.mouseover = this.touchstart = function (data) {
                    this.tint = 0x178c77;
                };
                // Suppression de celle-ci une fois que la souris quitte la Tile
                this.mouseout = this.touchend = function (data) {
                    this.tint = 0xffffff;
                };
            }
            else {
                this.interactive = false;
            }
        };
        return Tile;
    })(PIXI.Sprite);
    Engine.Tile = Tile;
})(Engine || (Engine = {}));
//# sourceMappingURL=Tile.js.map
///<reference path="./defLoader.d.ts" />
/**
 * Tileset
 *
 * @module :: Tileset
 * @description	:: Classe statique permettant de manager les Tilesets.
 */
var Engine;
(function (Engine) {
    var Tileset = (function () {
        function Tileset() {
        }
        /**
         * Permet la r�cup�ration d'un tileset d'apr�s son Url.
         * @method getTileset
         * @static
         *
         * @param tilesetUrl {string}       Url du Tileset � r�cup�rer
         * @return {TilesetLoader}          Retourne l'objet TilesetLoader qui lui contient les Tiles d�coup�es
         */
        Tileset.getTileset = function (tilesetUrl) {
            if (this._tilesetList[tilesetUrl]) {
                if (this._tilesetList[tilesetUrl].isReady()) {
                    return this._tilesetList[tilesetUrl];
                }
                else {
                    throw ('Tileset is not ready : ' + tilesetUrl);
                }
            }
            else {
                throw ('Unknown Tileset : ' + tilesetUrl);
            }
        };
        /**
         * Permet le chargement d'une liste de Tileset
         * @method load
         * @static
         *
         * @param tilesetList {string[]}    Array contenant une liste d'Url de Tileset � charger
         */
        Tileset.load = function (tilesetList) {
            if (tilesetList.length > 0) {
                for (var i = 0, ls = tilesetList.length; i < ls; i++) {
                    if (!this._tilesetList[tilesetList[i]]) {
                        this._tilesetList[tilesetList[i]] = new Engine.TilesetLoader(tilesetList[i]);
                    }
                }
            }
        };
        /**
         * Permet d'assign� un callback quand un Tileset est charger et ses Tiles sont d�coup�s
         * @method onReady
         * @static
         *
         * @param tilesetUrl {string}       Url du Tileset
         * @param cb {function}             Callback une fois le Tileset charger et d�couper
         */
        Tileset.onReady = function (tilesetUrl, cb) {
            // V�rification de l'existance du Tileset dans la liste
            if (this._tilesetList[tilesetUrl]) {
                this._tilesetList[tilesetUrl].onReady(cb);
            }
            else {
                throw ('Unknown Tileset : ' + tilesetUrl);
            }
        };
        /**
         * Contient la liste des Tilesets actuellement utilis�.
         *
         * @property _tilesetList
         * @type {object}
         * @private
         */
        Tileset._tilesetList = {};
        return Tileset;
    })();
    Engine.Tileset = Tileset;
})(Engine || (Engine = {}));
//# sourceMappingURL=Tileset.js.map
///<reference path="./defLoader.d.ts" />
var __extends = this.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    __.prototype = b.prototype;
    d.prototype = new __();
};
/**
 * TilesetLoader
 *
 * @module :: TilesetLoader
 * @description	:: Classe permettant le chargement et d�coupage d'un Tileset.
 */
var Engine;
(function (Engine) {
    var TilesetLoader = (function (_super) {
        __extends(TilesetLoader, _super);
        /**
         * Constructeur
         *
         * @param tilesetUrl {string}       Url du Tileset
         */
        function TilesetLoader(tilesetUrl) {
            _super.call(this, tilesetUrl, true);
            /**
             * Array contenant une liste de callback � envoyer une fois le Tileset charger et d�couper
             *
             * @property _onReadyCb
             * @type {function[]}
             * @private
             */
            this._onReadyCb = [];
            /**
             * Status actuel du Tileset (d�coup� et charg�)
             *
             * @property _ready
             * @type {boolean}
             * @private
             */
            this._ready = false;
            /**
             * Array contenant la liste des Textures des Tiles qui ont �t� d�couper du Tileset
             *
             * @property _tileList
             * @type {PIXI.Texture[]}
             * @private
             */
            this._tileList = [];
            // Scope
            var self = this;
            // Une fois le Tileset charg�, on demande le d�coupage des Tiles
            this.on('loaded', function () {
                self._cutTiles();
            });
            // Lancement du chargement du Tileset
            this.load();
        }
        /**
         * Permet la d�coupe de toute les Tiles du Tileset
         * @method _cutTiles
         * @private
         */
        TilesetLoader.prototype._cutTiles = function () {
            for (var i = 0, textureHeight = Math.floor(this.texture.height / Engine.Config.tileTextureHeight); i < textureHeight; i++) {
                for (var j = 0, textureWidth = Math.floor(this.texture.width / Engine.Config.tileTextureWidth); j < textureWidth; j++) {
                    // On calcule les diff�rentes positions des Tiles
                    var tilePosition = new PIXI.Rectangle(j * Engine.Config.tileTextureWidth, i * Engine.Config.tileTextureHeight, Engine.Config.tileTextureWidth, Engine.Config.tileTextureHeight);
                    // On cr�e la texture de la Tile
                    var tTile = new PIXI.Texture(this.texture.baseTexture, tilePosition);
                    // On ajoute la texture au tableau des Tiles
                    this._tileList.push(tTile);
                }
            }
            // On peut consid�rer que le Tileset est maintenant pr�t
            this._ready = true;
            for (var i = 0, ls = this._onReadyCb.length; i < ls; i++) {
                this._onReadyCb[i](this);
            }
        };
        /**
         * Permet de r�cup�r� la texture d'une Tile d'apr�s son num�ro
         * @method getTile
         *
         * @param tileNumber {number}       Numero de la Tile qui doit �tre r�cup�r�
         * @return {PIXI.Texture}           Retourne la texture de la Tile
         */
        TilesetLoader.prototype.getTile = function (tileNumber) {
            if (tileNumber > -1 && tileNumber < this._tileList.length) {
                return this._tileList[tileNumber];
            }
            else {
                console.warn('Vous essayer d\'utiliser un num�ro de Tile inexistant : ' + tileNumber);
                return this._tileList[0];
            }
        };
        /**
         * Permet de conna�tre si le Tileset est pr�t � �tre utiliser.
         * @method isReady
         *
         * @return {boolean}                Retourne le status du Tileset
         */
        TilesetLoader.prototype.isReady = function () {
            return this._ready;
        };
        /**
         * Permet d'ajouter un callback une fois que le Tileset est charg�.
         * @method onReady
         *
         * @param cb {function}             Callback � �xecuter une fois le Tileset charg�
         */
        TilesetLoader.prototype.onReady = function (cb) {
            // Si le Tileset est d�j� charg�, on envoie directement le Callback. Sinon, on l'ajoute � la liste.
            if (this._ready) {
                cb(this);
            }
            else {
                this._onReadyCb.push(cb);
            }
        };
        return TilesetLoader;
    })(PIXI.ImageLoader);
    Engine.TilesetLoader = TilesetLoader;
})(Engine || (Engine = {}));
//# sourceMappingURL=TilesetLoader.js.map
///<reference path="./defLoader.d.ts" />
/**
 * Utils
 *
 * @module :: Utils
 * @description	:: Classe statique contenant divers utilitaires
 */
var Engine;
(function (Engine) {
    var Utils = (function () {
        function Utils() {
        }
        /**
         * Permet de généré automatiquement une carte d'après divers paramètres tel que la largeur/hauteur et les numero des Tiles à utilisés.
         *
         * @method generateMap
         * @static
         *
         * @param width                 Largeur de la carte
         * @param height                Hauteur de la carte
         * @param tileNumberMin         Numero minimum des Tiles à utilisés
         * @param tileNumberMax         Numero maximum des Tiles à utilisés
         * @return {number[]}           Retourne le tableau contenant les numero des Tiles à dessiné
         */
        Utils.generateMap = function (width, height, tileNumberMin, tileNumberMax) {
            var out = [];
            for (var i = 0, mapLength = width * height; i < mapLength; i++) {
                out.push(Math.floor((Math.random() * tileNumberMax) + tileNumberMin));
            }
            return out;
        };
        return Utils;
    })();
    Engine.Utils = Utils;
})(Engine || (Engine = {}));
//# sourceMappingURL=Utils.js.map
// Création du rendu
Engine.SceneManager.create(Engine.Config.gameScreenX, Engine.Config.gameScreenY, {
    antialiasing:false,
    transparent:true,
    resolution:1
}, 'showExample');

// Création des différentes Scènes du "jeu"
Engine.SceneManager.createScene('game', Engine.GameScene);
Engine.SceneManager.createScene('intro', Engine.IntroScene);

// On entre dans la Scène d'introduction
Engine.SceneManager.goToScene('intro');